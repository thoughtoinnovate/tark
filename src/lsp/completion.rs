//! LSP completion handler

use super::document::DocumentStore;
use crate::completion::{CompletionEngine, CompletionRequest};
use anyhow::Result;
use std::path::PathBuf;
use std::sync::Arc;
use tower_lsp::lsp_types::*;

/// Handle completion request
pub async fn handle_completion(
    engine: &Arc<CompletionEngine>,
    documents: &Arc<DocumentStore>,
    params: CompletionParams,
) -> Result<Option<CompletionResponse>> {
    let uri = params.text_document_position.text_document.uri;
    let position = params.text_document_position.position;

    let doc = match documents.get(&uri) {
        Some(d) => d,
        None => return Ok(None),
    };

    // Convert URI to file path
    let file_path = uri
        .to_file_path()
        .unwrap_or_else(|_| PathBuf::from(uri.path()));

    let request = CompletionRequest {
        file_path,
        file_content: doc.content.clone(),
        cursor_line: position.line as usize,
        cursor_col: position.character as usize,
        related_files: vec![],
    };

    match engine.complete(&request).await {
        Ok(response) => {
            if response.completion.is_empty() {
                return Ok(None);
            }

            // Create completion item
            let item = CompletionItem {
                label: truncate_label(&response.completion, 50),
                kind: Some(CompletionItemKind::TEXT),
                detail: Some("AI completion".to_string()),
                documentation: Some(Documentation::String("Generated by tark".to_string())),
                insert_text: Some(response.completion),
                insert_text_format: Some(InsertTextFormat::PLAIN_TEXT),
                ..Default::default()
            };

            Ok(Some(CompletionResponse::Array(vec![item])))
        }
        Err(e) => {
            tracing::error!("Completion error: {}", e);
            Ok(None)
        }
    }
}

fn truncate_label(s: &str, max_len: usize) -> String {
    let first_line = s.lines().next().unwrap_or(s);
    if first_line.len() <= max_len {
        first_line.to_string()
    } else {
        format!("{}...", &first_line[..max_len - 3])
    }
}
