// tark.wit - WebAssembly Interface Types for tark plugins
//
// This file defines the contract between tark (host) and plugins (guest).
// Plugins import interfaces they need and export interfaces they implement.

package tark:plugin;

// ============================================================================
// Host-provided interfaces (plugins import these)
// ============================================================================

/// Persistent storage for plugin data
interface storage {
    /// Get a value by key
    /// Returns None if key doesn't exist
    get: func(key: string) -> option<string>;
    
    /// Set a value for a key
    /// Overwrites existing value
    set: func(key: string, value: string) -> result<_, string>;
    
    /// Delete a key
    delete: func(key: string) -> result<_, string>;
    
    /// List all keys
    list-keys: func() -> list<string>;
}

/// HTTP client for making requests
interface http {
    /// HTTP response
    record http-response {
        status: u16,
        headers: list<tuple<string, string>>,
        body: string,
    }
    
    /// HTTP error
    record http-error {
        message: string,
        status: option<u16>,
    }
    
    /// Make a GET request
    get: func(url: string, headers: list<tuple<string, string>>) 
         -> result<http-response, http-error>;
    
    /// Make a POST request
    post: func(url: string, body: string, headers: list<tuple<string, string>>) 
          -> result<http-response, http-error>;
}

/// WebSocket client
interface ws {
    /// Connect to a WebSocket URL
    /// headers are optional (JSON encoded in plugin implementations)
    connect: func(url: string, headers-json: string) -> string;

    /// Send a text message on a WebSocket
    send: func(handle: s64, data: string) -> string;

    /// Receive a text message on a WebSocket
    recv: func(handle: s64, timeout-ms: s64, max-bytes: s64) -> string;

    /// Close a WebSocket connection
    close: func(handle: s64) -> string;
}

/// Environment variable access
interface env {
    /// Get an environment variable
    /// Returns None if not set or not allowed
    get: func(name: string) -> option<string>;
}

/// Logging
interface log {
    /// Log at debug level
    debug: func(message: string);
    
    /// Log at info level
    info: func(message: string);
    
    /// Log at warn level
    warn: func(message: string);
    
    /// Log at error level
    error: func(message: string);
}

/// Filesystem access (read-only, capability-controlled)
/// Plugin must declare allowed paths in capabilities.fs_read
interface fs {
    /// Read a file from an allowed path
    /// Supports ~ for home directory expansion
    /// Returns file contents on success, error on failure
    /// Error codes: -1 = invalid path, -2 = permission denied, -3 = read error
    read: func(path: string) -> result<string, string>;
}

// ============================================================================
// Plugin-provided interfaces (plugins export these)
// ============================================================================

/// Authentication plugin interface
interface auth-plugin {
    /// Device code response for OAuth device flow
    record device-code {
        device-code: string,
        user-code: string,
        verification-url: string,
        expires-in: u64,
        interval: u64,
    }
    
    /// Authentication status
    enum auth-status {
        not-authenticated,
        authenticated,
        expired,
    }
    
    /// Poll result
    variant poll-result {
        pending,
        success(string),
        expired,
        error(string),
    }
    
    /// Get plugin display name
    display-name: func() -> string;
    
    /// Get current authentication status
    status: func() -> auth-status;
    
    /// Start device flow authentication
    start-device-flow: func() -> result<device-code, string>;
    
    /// Poll for token (call after user authorizes)
    poll: func(device-code: string) -> poll-result;
    
    /// Get current access token (if authenticated)
    get-token: func() -> result<string, string>;
    
    /// Logout (clear stored credentials)
    logout: func() -> result<_, string>;
}

/// Tool plugin interface
interface tool-plugin {
    /// Tool definition
    record tool-def {
        name: string,
        description: string,
        parameters-schema: string,
    }
    
    /// Tool execution result
    record tool-result {
        success: bool,
        output: string,
        error: option<string>,
    }
    
    /// Risk level for the tool
    enum risk-level {
        read-only,
        write,
        risky,
        dangerous,
    }
    
    /// Get tool definitions
    get-tools: func() -> list<tool-def>;
    
    /// Get risk level for a tool
    get-risk-level: func(tool-name: string) -> risk-level;
    
    /// Execute a tool
    execute: func(tool-name: string, arguments: string) -> tool-result;
}

/// LLM provider plugin interface (full-featured)
interface provider-plugin {
    /// Provider metadata
    record provider-info {
        /// Provider ID (e.g., "gemini-oauth")
        id: string,
        /// Display name (e.g., "Gemini (OAuth)")
        display-name: string,
        /// Description
        description: string,
        /// Whether provider requires authentication
        requires-auth: bool,
    }
    
    /// Model info
    record model-info {
        id: string,
        display-name: string,
        context-window: u32,
        supports-streaming: bool,
        supports-tools: bool,
    }
    
    /// Message role
    enum role {
        system,
        user,
        assistant,
        tool,
    }
    
    /// Chat message
    record message {
        role: role,
        content: string,
    }
    
    /// Token usage
    record usage {
        input-tokens: u32,
        output-tokens: u32,
    }
    
    /// Chat response
    record chat-response {
        text: string,
        usage: option<usage>,
        finish-reason: option<string>,
    }
    
    /// Stream chunk for streaming responses
    record stream-chunk {
        text: string,
        done: bool,
        usage: option<usage>,
    }
    
    /// Auth status for provider
    enum auth-status {
        not-required,
        authenticated,
        not-authenticated,
        expired,
    }
    
    // === Provider Info ===
    
    /// Get provider metadata
    info: func() -> provider-info;
    
    /// Get available models
    models: func() -> list<model-info>;
    
    // === Authentication ===
    
    /// Get authentication status
    auth-status: func() -> auth-status;
    
    /// Initialize with credentials (JSON)
    auth-init: func(credentials-json: string) -> result<_, string>;
    
    /// Logout
    auth-logout: func() -> result<_, string>;
    
    // === Chat ===
    
    /// Send chat completion (non-streaming)
    chat: func(messages: list<message>, model: string) -> result<chat-response, string>;
    
    /// Send chat completion (streaming) - returns stream ID
    chat-stream-start: func(messages: list<message>, model: string) -> result<u64, string>;
    
    /// Poll stream for next chunk
    chat-stream-poll: func(stream-id: u64) -> result<stream-chunk, string>;
}

/// Messaging channel plugin interface
interface channel-plugin {
    /// Channel metadata
    record channel-info {
        id: string,
        display-name: string,
        description: string,
        supports-streaming: bool,
        supports-edits: bool,
    }

    /// Inbound message from a channel
    record inbound-message {
        conversation-id: string,
        user-id: string,
        text: string,
        metadata-json: string,
    }

    /// Webhook request from host
    record webhook-request {
        method: string,
        path: string,
        query: option<string>,
        headers: list<tuple<string, string>>,
        body: string,
    }

    /// Webhook response to return to caller
    record webhook-response {
        status: u16,
        headers: list<tuple<string, string>>,
        body: string,
        messages: list<inbound-message>,
    }

    /// Outbound message from agent to channel
    record outbound-message {
        conversation-id: string,
        text: string,
        message-id: option<string>,
        is-final: bool,
        metadata-json: string,
    }

    /// Send result
    record send-result {
        success: bool,
        message-id: option<string>,
        error: option<string>,
    }

    /// Auth status for channel
    enum auth-status {
        not-required,
        authenticated,
        not-authenticated,
        expired,
    }

    /// Get channel metadata
    info: func() -> channel-info;

    /// Start the channel plugin
    start: func() -> result<_, string>;

    /// Stop the channel plugin
    stop: func() -> result<_, string>;

    /// Get authentication status
    auth-status: func() -> auth-status;

    /// Initialize with credentials (JSON)
    auth-init: func(credentials-json: string) -> result<_, string>;

    /// Logout
    auth-logout: func() -> result<_, string>;

    /// Optional widget state (JSON)
    widget-state: func() -> result<string, string>;

    /// Handle inbound webhook request
    handle-webhook: func(request: webhook-request) -> result<webhook-response, string>;

    /// Handle inbound gateway event (JSON payload)
    /// Returns a list of inbound messages parsed from the event.
    handle-gateway-event: func(payload-json: string) -> result<list<inbound-message>, string>;

    /// Poll channel for new messages (optional)
    poll: func() -> result<list<inbound-message>, string>;

    /// Send outbound message
    send: func(message: outbound-message) -> result<send-result, string>;
}

// ============================================================================
// World definitions (what plugins export)
// ============================================================================

/// Auth plugin world
world auth-world {
    import storage;
    import http;
    import env;
    import log;
    import fs;
    
    export auth-plugin;
}

/// Tool plugin world
world tool-world {
    import storage;
    import http;
    import env;
    import log;
    import fs;
    
    export tool-plugin;
}

/// Provider plugin world
world provider-world {
    import storage;
    import http;
    import env;
    import log;
    import fs;
    
    export provider-plugin;
}

/// Channel plugin world
world channel-world {
    import storage;
    import http;
    import ws;
    import env;
    import log;
    import fs;

    export channel-plugin;
}
